/* 
 * Apteco API
 *
 * An API to allow access to Apteco Marketing Suite resources
 *
 * OpenAPI spec version: v2
 * Contact: support@apteco.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using SwaggerDateConverter = Apteco.ApiSystemAnalyser.ApiClient.Client.SwaggerDateConverter;

namespace Apteco.ApiSystemAnalyser.ApiClient.Model
{
    /// <summary>
    /// A dimension to define the categories to break the data in the cube down by
    /// </summary>
    [DataContract]
    public partial class Dimension :  IEquatable<Dimension>
    {
        /// <summary>
        /// The type of the dimension
        /// </summary>
        /// <value>The type of the dimension</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum TypeEnum
        {
            
            /// <summary>
            /// Enum Selector for value: Selector
            /// </summary>
            [EnumMember(Value = "Selector")]
            Selector = 1,
            
            /// <summary>
            /// Enum NumericBand for value: NumericBand
            /// </summary>
            [EnumMember(Value = "NumericBand")]
            NumericBand = 2,
            
            /// <summary>
            /// Enum DateBand for value: DateBand
            /// </summary>
            [EnumMember(Value = "DateBand")]
            DateBand = 3,
            
            /// <summary>
            /// Enum Text for value: Text
            /// </summary>
            [EnumMember(Value = "Text")]
            Text = 4,
            
            /// <summary>
            /// Enum Query for value: Query
            /// </summary>
            [EnumMember(Value = "Query")]
            Query = 5
        }

        /// <summary>
        /// The type of the dimension
        /// </summary>
        /// <value>The type of the dimension</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public TypeEnum Type { get; set; }
        /// <summary>
        /// Details of the function to use for this dimension
        /// </summary>
        /// <value>Details of the function to use for this dimension</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum FunctionEnum
        {
            
            /// <summary>
            /// Enum None for value: None
            /// </summary>
            [EnumMember(Value = "None")]
            None = 1,
            
            /// <summary>
            /// Enum Sum for value: Sum
            /// </summary>
            [EnumMember(Value = "Sum")]
            Sum = 2,
            
            /// <summary>
            /// Enum Mean for value: Mean
            /// </summary>
            [EnumMember(Value = "Mean")]
            Mean = 3,
            
            /// <summary>
            /// Enum Min for value: Min
            /// </summary>
            [EnumMember(Value = "Min")]
            Min = 4,
            
            /// <summary>
            /// Enum Max for value: Max
            /// </summary>
            [EnumMember(Value = "Max")]
            Max = 5,
            
            /// <summary>
            /// Enum Median for value: Median
            /// </summary>
            [EnumMember(Value = "Median")]
            Median = 6,
            
            /// <summary>
            /// Enum Mode for value: Mode
            /// </summary>
            [EnumMember(Value = "Mode")]
            Mode = 7,
            
            /// <summary>
            /// Enum Distinct for value: Distinct
            /// </summary>
            [EnumMember(Value = "Distinct")]
            Distinct = 8,
            
            /// <summary>
            /// Enum Frequency for value: Frequency
            /// </summary>
            [EnumMember(Value = "Frequency")]
            Frequency = 9,
            
            /// <summary>
            /// Enum Recency for value: Recency
            /// </summary>
            [EnumMember(Value = "Recency")]
            Recency = 10,
            
            /// <summary>
            /// Enum RankCoefficient for value: RankCoefficient
            /// </summary>
            [EnumMember(Value = "RankCoefficient")]
            RankCoefficient = 11
        }

        /// <summary>
        /// Details of the function to use for this dimension
        /// </summary>
        /// <value>Details of the function to use for this dimension</value>
        [DataMember(Name="function", EmitDefaultValue=false)]
        public FunctionEnum? Function { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Dimension" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Dimension() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Dimension" /> class.
        /// </summary>
        /// <param name="Id">The id of the dimension (required).</param>
        /// <param name="Type">The type of the dimension (required).</param>
        /// <param name="Query">If the dimension is a query dimension - the definition of the query to use.</param>
        /// <param name="VariableName">If the dimension is a selector, numeric, date or text dimension then the name of the variable to use.</param>
        /// <param name="Banding">If the dimension is banded, details of the banding to use.</param>
        /// <param name="Function">Details of the function to use for this dimension.</param>
        /// <param name="NoneCell">If this dimension represents something for a table lower down the hierarchy to the cube&#39;s resolve table,  whether to include a cell for where there a no records on the lower table.  I.e. for where a person has no orders.</param>
        /// <param name="OmitUnclassified">If this dimension represents a selector with an unclassified code, whether to omit this from the cube.</param>
        public Dimension(string Id = default(string), TypeEnum Type = default(TypeEnum), Query Query = default(Query), string VariableName = default(string), DimensionBanding Banding = default(DimensionBanding), FunctionEnum? Function = default(FunctionEnum?), bool? NoneCell = default(bool?), bool? OmitUnclassified = default(bool?))
        {
            // to ensure "Id" is required (not null)
            if (Id == null)
            {
                throw new InvalidDataException("Id is a required property for Dimension and cannot be null");
            }
            else
            {
                this.Id = Id;
            }
            // to ensure "Type" is required (not null)
            if (Type == null)
            {
                throw new InvalidDataException("Type is a required property for Dimension and cannot be null");
            }
            else
            {
                this.Type = Type;
            }
            this.Query = Query;
            this.VariableName = VariableName;
            this.Banding = Banding;
            this.Function = Function;
            this.NoneCell = NoneCell;
            this.OmitUnclassified = OmitUnclassified;
        }
        
        /// <summary>
        /// The id of the dimension
        /// </summary>
        /// <value>The id of the dimension</value>
        [DataMember(Name="id", EmitDefaultValue=false)]
        public string Id { get; set; }


        /// <summary>
        /// If the dimension is a query dimension - the definition of the query to use
        /// </summary>
        /// <value>If the dimension is a query dimension - the definition of the query to use</value>
        [DataMember(Name="query", EmitDefaultValue=false)]
        public Query Query { get; set; }

        /// <summary>
        /// If the dimension is a selector, numeric, date or text dimension then the name of the variable to use
        /// </summary>
        /// <value>If the dimension is a selector, numeric, date or text dimension then the name of the variable to use</value>
        [DataMember(Name="variableName", EmitDefaultValue=false)]
        public string VariableName { get; set; }

        /// <summary>
        /// If the dimension is banded, details of the banding to use
        /// </summary>
        /// <value>If the dimension is banded, details of the banding to use</value>
        [DataMember(Name="banding", EmitDefaultValue=false)]
        public DimensionBanding Banding { get; set; }


        /// <summary>
        /// If this dimension represents something for a table lower down the hierarchy to the cube&#39;s resolve table,  whether to include a cell for where there a no records on the lower table.  I.e. for where a person has no orders
        /// </summary>
        /// <value>If this dimension represents something for a table lower down the hierarchy to the cube&#39;s resolve table,  whether to include a cell for where there a no records on the lower table.  I.e. for where a person has no orders</value>
        [DataMember(Name="noneCell", EmitDefaultValue=false)]
        public bool? NoneCell { get; set; }

        /// <summary>
        /// If this dimension represents a selector with an unclassified code, whether to omit this from the cube
        /// </summary>
        /// <value>If this dimension represents a selector with an unclassified code, whether to omit this from the cube</value>
        [DataMember(Name="omitUnclassified", EmitDefaultValue=false)]
        public bool? OmitUnclassified { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Dimension {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Query: ").Append(Query).Append("\n");
            sb.Append("  VariableName: ").Append(VariableName).Append("\n");
            sb.Append("  Banding: ").Append(Banding).Append("\n");
            sb.Append("  Function: ").Append(Function).Append("\n");
            sb.Append("  NoneCell: ").Append(NoneCell).Append("\n");
            sb.Append("  OmitUnclassified: ").Append(OmitUnclassified).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Dimension);
        }

        /// <summary>
        /// Returns true if Dimension instances are equal
        /// </summary>
        /// <param name="input">Instance of Dimension to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Dimension input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.Query == input.Query ||
                    (this.Query != null &&
                    this.Query.Equals(input.Query))
                ) && 
                (
                    this.VariableName == input.VariableName ||
                    (this.VariableName != null &&
                    this.VariableName.Equals(input.VariableName))
                ) && 
                (
                    this.Banding == input.Banding ||
                    (this.Banding != null &&
                    this.Banding.Equals(input.Banding))
                ) && 
                (
                    this.Function == input.Function ||
                    (this.Function != null &&
                    this.Function.Equals(input.Function))
                ) && 
                (
                    this.NoneCell == input.NoneCell ||
                    (this.NoneCell != null &&
                    this.NoneCell.Equals(input.NoneCell))
                ) && 
                (
                    this.OmitUnclassified == input.OmitUnclassified ||
                    (this.OmitUnclassified != null &&
                    this.OmitUnclassified.Equals(input.OmitUnclassified))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Id != null)
                    hashCode = hashCode * 59 + this.Id.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.Query != null)
                    hashCode = hashCode * 59 + this.Query.GetHashCode();
                if (this.VariableName != null)
                    hashCode = hashCode * 59 + this.VariableName.GetHashCode();
                if (this.Banding != null)
                    hashCode = hashCode * 59 + this.Banding.GetHashCode();
                if (this.Function != null)
                    hashCode = hashCode * 59 + this.Function.GetHashCode();
                if (this.NoneCell != null)
                    hashCode = hashCode * 59 + this.NoneCell.GetHashCode();
                if (this.OmitUnclassified != null)
                    hashCode = hashCode * 59 + this.OmitUnclassified.GetHashCode();
                return hashCode;
            }
        }
    }

}
